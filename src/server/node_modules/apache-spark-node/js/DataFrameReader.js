"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataFrame = require("./DataFrame.js");
var java = require("./java");

/**
 * Interface used to load a {@link DataFrame} from external storage systems (e.g. file systems,
 * key-value stores, etc). Use {@link SQLContext#read} to access this.
 *
 * @since 1.4.0
 */

var DataFrameReader = function () {

    /**
     * **Note:** Do not use directly (see above).
     */
    function DataFrameReader(sqlContext /*: SQLContext*/) {
        _classCallCheck(this, DataFrameReader);

        var jvm_DataFrameReader = java.import("org.apache.spark.sql.DataFrameReader");
        this.sqlContext = sqlContext;
        this.jvm_obj = new jvm_DataFrameReader(sqlContext.jvm_obj);
    }

    /**
     * Not documenting this for now, redundant with json() and text()
     *
     * Specifies the input data source format.
     *
     * @private
     * @since 1.4.0
     */


    _createClass(DataFrameReader, [{
        key: "format",
        value: function format(source /*: String */) /*: DataFrameReader */{
            this.jvm_obj.format(source);
            return this;
        }

        /**
         * Not documenting this for now, redundant with json() and text()
         *
         * Loads data from a data source and returns it as a {@link DataFrame}.
         *
         * @private
         * @param [path=null] Optional path for file-system backed data sources.
         * @since 1.4.0
         */

    }, {
        key: "load",
        value: function load(path /*: String */, cb /*: cb: (err: any, res: DataFrame) => any */) /*: void */{
            this.option("path", path);
            this.jvm_obj.loadAsync(function (err, jvm_df) {
                if (err) return cb(err);
                cb(err, new DataFrame(jvm_df));
            });
        }
    }, {
        key: "loadSync",
        value: function loadSync(path /*: String */) /*: DataFrame */{
            this.option("path", path);
            return new DataFrame(this.jvm_obj.load());
        }

        /**
         * Adds an input option for the underlying data source.
         *
         * @param key
         * @param value
         * @since 1.4.0
         */

    }, {
        key: "option",
        value: function option(key /*: String */, value /*: String */) /*: DataFrameReader */{
            this.jvm_obj.option(key, value);
            return this;
        }

        /**
         * Loads a JSON file (one object per line) and returns the result as a {@link DataFrame}.
         *
         * This function goes through the input once to determine the input schema.
         *
         * You can set the following JSON-specific options using {@link DataFrameReader#option} to deal with non-standard JSON files:
         * <li>`primitivesAsString` (default `false`): infers all primitive values as a string type</li>
         * <li>`allowComments` (default `false`): ignores Java/C++ style comment in JSON records</li>
         * <li>`allowUnquotedFieldNames` (default `false`): allows unquoted JSON field names</li>
         * <li>`allowSingleQuotes` (default `true`): allows single quotes in addition to double quotes
         * </li>
         * <li>`allowNumericLeadingZeros` (default `false`): allows leading zeros in numbers
         * (e.g. 00012)</li>
         *
         * @param path
         * @param cb Node-style callback function (error-first).
         * @since 1.4.0
         */

    }, {
        key: "json",
        value: function json(path /*: String */, cb /*: cb: (err: any, res: DataFrame) => any */) /*: void */{
            this.format("json").load(path, cb);
        }

        /**
         * The synchronous version of {@link DataFrameReader#json}
         *
         * @param path
         * @since 1.4.0
         */

    }, {
        key: "jsonSync",
        value: function jsonSync(path /*: String */) /*: DataFrame */{
            return this.format("json").loadSync(path);
        }
    }, {
        key: "jsonRDD_",
        value: function jsonRDD_(jrdd /*: javaRDD[String] */) /*: DataFrame */{
            return new DataFrame(this.jvm_obj.json(jrdd));
        }

        /**
         * Loads a text file and returns a {@link DataFrame} with a single string
         * column named "text". Each line in the text file is a new row in the
         * resulting DataFrame.
         *
         * @param cb Node-style callback function (error-first).
         * @param path
         * @since 1.6.0
         */

    }, {
        key: "text",
        value: function text(path /*: String */, cb /*: cb: (err: any, res: DataFrame) => any */) /*: DataFrame */{
            return this.format("text").load(path, cb);
        }

        /**
         * The synchronous version of {@link DataFrameReader#text}
         *
         * @param path
         * @since 1.6.0
         */

    }, {
        key: "textSync",
        value: function textSync(path /*: String */) /*: DataFrame */{
            return this.format("text").loadSync(path);
        }
    }]);

    return DataFrameReader;
}();

module.exports = DataFrameReader;