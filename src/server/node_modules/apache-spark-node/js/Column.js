"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A column that will be computed based on the data in a {@link DataFrame}.
 *
 * A new column is constructed based on the input columns present in a dataframe:
 *
 * ```
 *   df.col("columnName")          // On a specific DataFrame.
 *   var F = sqlFunctions;
 *   F.col("columnName")           // A generic column no yet associcated with a DataFrame.
 *   F.col("columnName.field")     // Extracting a struct field
 *   F.col("`a.column.with.dots`") // Escape `.` in column names.
 *   F.expr("a + 1")               // A column that is constructed from a parsed SQL Expression.
 *   F.lit("abc")                  // A column that produces a literal (constant) value.
 * ```
 * @since 1.3.0
 */
var Column = function () {

  /**
   * **Note:** Do not use directly (see above).
   */
  function Column(jvm_obj) {
    _classCallCheck(this, Column);

    this.jvm_obj = jvm_obj;
  }

  /**
   * Equality test.
   * @example
   *   df.filter(F.col("colA").equalTo(F.col("colB")) );
   *
   * @param other
   * @since 1.3.0
   */


  _createClass(Column, [{
    key: "equalTo",
    value: function equalTo(other /*: Any*/) /*: Column*/{
      return new Column(this.jvm_obj.equalTo(other));
    }

    /**
     * Greater than.
     *
     * @example
     *   people.select(people.col("age").gt(21));
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "gt",
    value: function gt(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.gt(other));
    }

    /**
     * Less than.
     *
     * @example
     *   people.select( people.col("age").lt(21) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "lt",
    value: function lt(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.lt(other));
    }

    /**
     * Less than or equal to.
     *
     * @example
     *   people.select( people.col("age").leq(21) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "leq",
    value: function leq(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.leq(other));
    }

    /**
     * Greater than or equal to an expression.
     *
     * @example
     *   people.select( people.col("age").geq(21) )
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "geq",
    value: function geq(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.geq(other));
    }

    /**
     * Equality test that is safe for null values.
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "eqNullSafe",
    value: function eqNullSafe(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.eqNullSafe(other));
    }

    /**
     * Evaluates a list of conditions and returns one of multiple possible result expressions.
     * If otherwise is not defined at the end, null is returned for unmatched conditions.
     *
     * @example
     *   // Example: encoding gender string column into integer.
     *
     *   people.select(when(F.col("gender").equalTo("male"), 0)
     *     .when(F.col("gender").equalTo("female"), 1)
     *     .otherwise(2))
     *
     * @param value
     * @since 1.4.0
     */

  }, {
    key: "otherwise",
    value: function otherwise(value /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.otherwise(value));
    }

    /**
     * True if the current column is between the lower bound and upper bound, inclusive.
     *
     * @param lowerBound
     * @param upperBound
     * @since 1.4.0
     */

  }, {
    key: "between",
    value: function between(lowerBound /*: Any */, upperBound /*: Any*/) /*: Column  */{
      return new Column(this.jvm_obj.between(lowerBound, upperBound));
    }

    /**
     * True if the current expression is NaN.
     *
     * @since 1.5.0
     */

  }, {
    key: "isNaN",
    value: function isNaN() /*: Column*/{
      return new Column(this.jvm_obj.isNaN());
    }

    /**
     * True if the current expression is null.
     *
     * @since 1.3.0
     */

  }, {
    key: "isNull",
    value: function isNull() /*: Column*/{
      return new Column(this.jvm_obj.isNull());
    }

    /**
     * True if the current expression is NOT null.
     *
     * @since 1.3.0
     */

  }, {
    key: "isNotNull",
    value: function isNotNull() /*: Column*/{
      return new Column(this.jvm_obj.isNotNull());
    }

    /**
     * Boolean OR.
     *
     * @example
     *   people.filter( people.col("inSchool").or(people.col("isEmployed")) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "or",
    value: function or(other /*: Column */) /*: Column  */{
      return new Column(this.jvm_obj.or(other));
    }

    /**
     * Boolean AND.
     *
     * @example
     *   people.select( people.col("inSchool").and(people.col("isEmployed")) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "and",
    value: function and(other /*: Column */) /*: Column  */{
      return new Column(this.jvm_obj.and(other));
    }

    /**
     * Sum of this expression and another expression.
     *
     * @param other
     *   people.select( people.col("height").plus(people.col("weight")) );
     *
     * @since 1.3.0
     */

  }, {
    key: "plus",
    value: function plus(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.plus(other));
    }

    /**
     * Subtraction. Subtract the other expression from this expression.
     *
     * @example
     *   people.select( people.col("height").minus(people.col("weight")) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "minus",
    value: function minus(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.minus(other));
    }

    /**
     * Multiplication of this expression and another expression.
     *
     * @example
     *   people.select( people.col("height").multiply(people.col("weight")) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "multiply",
    value: function multiply(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.multiply(other));
    }

    /**
     * Division this expression by another expression.
     * @example
     *
     *   people.select( people.col("height").divide(people.col("weight")) );
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "divide",
    value: function divide(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.divide(other));
    }

    /**
     * Modulo (a.k.a. remainder) expression.
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "mod",
    value: function mod(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.mod(other));
    }

    /**
     * A boolean expression that is evaluated to true if the value of this expression is contained
     * by the evaluated values of the arguments.
     *
     * @param list
     * @since 1.5.0
     */

  }, {
    key: "isin",
    value: function isin() /*: Any* */ /*: Column  */{
      var _jvm_obj;

      return new Column((_jvm_obj = this.jvm_obj).isin.apply(_jvm_obj, arguments));
    }

    /**
     * SQL like expression.
     *
     * @param literal
     * @since 1.3.0
     */

  }, {
    key: "like",
    value: function like(literal /*: String */) /*: Column  */{
      return new Column(this.jvm_obj.like(literal));
    }

    /**
     * SQL RLIKE expression (LIKE with Regex).
     *
     * @param literal
     * @since 1.3.0
     */

  }, {
    key: "rlike",
    value: function rlike(literal /*: String */) /*: Column  */{
      return new Column(this.jvm_obj.rlike(literal));
    }

    /**
     * An expression that gets an item at position `ordinal` out of an array,
     * or gets a value by key `key` in a {@link MapType}.
     *
     * @param key
     * @since 1.3.0
     */

  }, {
    key: "getItem",
    value: function getItem(key /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.getItem(key));
    }

    /**
     * An expression that gets a field by name in a {@link StructType}.
     *
     * @param fieldName
     * @since 1.3.0
     */

  }, {
    key: "getField",
    value: function getField(fieldName /*: String */) /*: Column  */{
      return new Column(this.jvm_obj.getField(fieldName));
    }

    /**
     * An expression that returns a substring.
     * @param startPos starting position (Column or Number).
     * @param len length of the substring (Column or Number).
     *
     * @since 1.3.0
     */

  }, {
    key: "substr",
    value: function substr(startPos /*: Column | Int */, len /*: Column | Int*/) /*: Column  */{
      return new Column(this.jvm_obj.substr(startPos, len));
    }

    /**
     * Contains the other element.
     *
     * @param other
     * @since 1.3.0
     */

  }, {
    key: "contains",
    value: function contains(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.contains(other));
    }

    /**
     * String starts with.
     *
     * @param other (Column or String).
     * @since 1.3.0
     */

  }, {
    key: "startsWith",
    value: function startsWith(other /*: Column */) /*: Column  */{
      return new Column(this.jvm_obj.startsWith(other));
    }

    /**
     * String ends with.
     *
     * @param other (Column or String).
     * @since 1.3.0
     */

  }, {
    key: "endsWith",
    value: function endsWith(other /*: Column */) /*: Column  */{
      return new Column(this.jvm_obj.endsWith(other));
    }

    /**
     * Gives the column an alias. Same as `as`.
     * @example
     *   // Renames colA to colB in select output.
     *   df.select(F.col("colA").alias("colB"))
     *
     * @param alias
     * @since 1.4.0
     */

  }, {
    key: "alias",
    value: function alias(_alias /*: String */) /*: Column  */{
      return new Column(this.jvm_obj.alias(_alias));
    }

    /**
     * Gives the column an alias. Same as `alias`.
     *
     * @param alias
     * @since 1.4.0
     */

  }, {
    key: "as",
    value: function as(alias /*: String */) /*: Column  */{
      return new Column(this.jvm_obj.as(alias));
    }

    /**
     * Casts the column to a different data type, using the canonical string representation
     * of the type. The supported types are: `string`, `boolean`, `byte`, `short`, `int`, `long`,
     * `float`, `double`, `decimal`, `date`, `timestamp`.
     * @example
     *   // Casts colA to integer.
     *   df.select(df.col("colA").cast("int"))
     *
     * @param to
     * @since 1.3.0
     */

  }, {
    key: "cast",
    value: function cast(to /*: String */) /*: Column  */{
      return new Column(this.jvm_obj.cast(to));
    }

    /**
     * Returns an ordering used in sorting.
     *
     * @example
     *   df.sort(df.col("age").desc());
     * @since 1.3.0
     */

  }, {
    key: "desc",
    value: function desc() /*: Column*/{
      return new Column(this.jvm_obj.desc());
    }

    /**
     * Returns an ordering used in sorting.
     *
     * @example
     *   df.sort(df.col("age").asc());
     *
     * @since 1.3.0
     */

  }, {
    key: "asc",
    value: function asc() /*: Column*/{
      return new Column(this.jvm_obj.asc());
    }

    /**
     * Prints the expression to the console for debugging purpose.
     *
     * @param extended
     * @since 1.3.0
     */

  }, {
    key: "explain",
    value: function explain(extended /*: Boolean */) /*: Unit  */{
      return new Column(this.jvm_obj.explain(extended));
    }

    /**
     * Compute bitwise OR of this expression with another expression.
     *
     * @example
     *   df.select(F.col("colA").bitwiseOR(F.col("colB")));
     * @param other
     * @since 1.4.0
     */

  }, {
    key: "bitwiseOR",
    value: function bitwiseOR(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.bitwiseOR(other));
    }

    /**
     * Compute bitwise AND of this expression with another expression.
     *
     * @example
     *   df.select(F.col("colA").bitwiseAND(F.col("colB")));
     * @param other
     * @since 1.4.0
     */

  }, {
    key: "bitwiseAND",
    value: function bitwiseAND(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.bitwiseAND(other));
    }

    /**
     * Compute bitwise XOR of this expression with another expression.
     *
     * @example
     *   df.select(F.col("colA").bitwiseXOR(F.col("colB")));
     *
     * @param other
     * @since 1.4.0
     */

  }, {
    key: "bitwiseXOR",
    value: function bitwiseXOR(other /*: Any */) /*: Column  */{
      return new Column(this.jvm_obj.bitwiseXOR(other));
    }
  }]);

  return Column;
}();

module.exports = Column;