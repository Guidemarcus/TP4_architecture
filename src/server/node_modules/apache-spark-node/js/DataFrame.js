"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataFrameWriter = require("./DataFrameWriter");
var GroupedData = require("./GroupedData");
var Column = require("./Column");
var Row = require("./Row");
var java = require("./java");
var helpers = require("./helpers");

/**
 * A distributed collection of data organized into named columns.
 *
 * DataFrames can be created using various functions in {@link SQLContext}.
 * They can be manipulated using the various domain-specific-language (DSL)
 * functions defined in: {@link DataFrame} (this class), {@link Column}, and
 * {@link Functions}.
 *
 * @example <caption>To select a column from the data frame, use the <code>col</code> method.</caption>
 *   var ageCol = people.col("age");
 *
 * @example <caption>Note that the {@link Column} type can also be manipulated through its various functions.</caption>
 *   // The following creates a new column that increases everybody's age by 10.
 *   people.col("age").plus(10);
 *
 * @example <caption>A more complete example.</caption>
 *   var people = sqlContext.read().json("...");
 *   var department = sqlContext.read().json("...");
 *
 *   people.filter("age > 30")
 *     .join(department, people.col("deptId").eq(department.col("id")))
 *     .groupBy(department.col("name"), people.col("gender"))
 *     .agg(F.avg(people.col("salary")), F.max(people.col("age")));
 *
 * @since 1.3.0
 */

var DataFrame = function () {

    /**
     * **Note:** Do not use directly (see above).
     */
    function DataFrame(jvm_obj) {
        _classCallCheck(this, DataFrame);

        this.jvm_obj = jvm_obj;
    }

    /**
     * Returns a new {@link DataFrame} with new specified column names.
     * @param colNames Array of new column names.
     * @since 1.3.0
     */


    _createClass(DataFrame, [{
        key: "toDF",
        value: function toDF() /*: String* */ /*: DataFrame*/{
            var _jvm_obj;

            var new_jvm_obj = (_jvm_obj = this.jvm_obj).toDF.apply(_jvm_obj, arguments);
            return new DataFrame(new_jvm_obj);
        }

        /**
         * Returns all column names as an array.
         *
         * @param cb Node-style callback function (error-first).
         * @since 1.3.0
         */

    }, {
        key: "columns",
        value: function columns(cb /*: cb: (err: any, res: Array[String]) =>  any */) /*: void */{
            this.jvm_obj.columnsAsync(cb);
        }

        /**
         * The synchronous version of {@link DataFrame#columns}
         * @since 1.3.0
         */

    }, {
        key: "columnsSync",
        value: function columnsSync() /*: Array[String]*/{
            return this.jvm_obj.columns();
        }

        /**
         * Prints the schema to the console in a nice tree format.
         *
         * This method runs a computation but is still synchronous, because it is
         * used in an interactive setting (shell).
         *
         * @since 1.3.0
         */

    }, {
        key: "printSchema",
        value: function printSchema() /*: Unit */{
            this.jvm_obj.printSchema();
        }

        /**
         * Prints the plans (logical and physical) to the console for debugging purposes.
         * @param {string} [extended=false]
         * @since 1.3.0
         */

    }, {
        key: "explain",
        value: function explain() /*: Boolean */ /*: Unit */{
            var extended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            this.jvm_obj.explain(extended);
        }

        /**
         * Returns true if the `collect` and `take` methods can be run locally
         * (without any Spark executors).
         * @since 1.3.0
         */

    }, {
        key: "isLocal",
        value: function isLocal() /*: Boolean*/{
            return this.jvm_obj.isLocal();
        }

        /**
         * Displays the {@link DataFrame} in a tabular form. Strings more than 20 characters will be
         * truncated, and all cells will be aligned right.
         *
         * This method runs a computation but is still synchronous, because it is
         * used in an interactive setting (shell).
         *
         * @param {Number} [numRows=20] Number of rows to show.
         *
         * @param {Boolean} [truncate=true] If true, strings more than 20 characters will
         *              be truncated and all cells will be aligned right.
         *
         * @since 1.3.0
         */

    }, {
        key: "show",
        value: function show() /*: Boolean */ /*: Unit */{
            var numRows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
            var truncate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            this.jvm_obj.show(numRows, truncate);
        }

        /**
         * Join with another {@link DataFrame}.
         *
         * If no `col` is provided, does a Cartesian join. (Note that cartesian
         * joins are very expensive without an extra filter that can be pushed
         * down).
         *
         * If a column name (string) is provided, does an equi-join.
         *
         * If a column expression is provided, uses that as a join expression.
         *
         * @example <caption>perform a full outer join between <code>df1</code> and <code>df2</code></caption>
         * df1.join(df2, col("df1Key").equalTo(col("df2Key")), "outer");
         *
         * @param right Right side of the join.
         * @param [col=null] Column name or join expression.
         * @param [joinType="inner"] One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`.
         * @since 1.3.0
         */

    }, {
        key: "join",
        value: function join(right /*: DataFrame */) /*: String*/ /*: DataFrame */{
            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var joinType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "inner";

            if (col === null) {
                return new DataFrame(this.jvm_obj.join(right.jvm_obj));
            } else {
                col = helpers.jobj_from_maybe_string(col);
                return new DataFrame(this.jvm_obj.join(right.jvm_obj, col, joinType));
            }
        }

        /**
         * Returns a new {@link DataFrame} sorted by the specified column, all in ascending order.
         * @param col {@link Column}
         * @param cols Array of additional column names or expressions to sort by.
         * @since 1.3.0
         */

    }, {
        key: "sort",
        value: function sort(col /*: (Column | String) */) /*: (Column* | String*) */ /*: DataFrame */{
            var _jvm_obj2;

            for (var _len = arguments.length, cols = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                cols[_key - 1] = arguments[_key];
            }

            col = helpers.jobj_from_maybe_string(col);
            cols = cols.map(helpers.jobj_from_maybe_string);
            return new DataFrame((_jvm_obj2 = this.jvm_obj).sort.apply(_jvm_obj2, [col].concat(_toConsumableArray(cols))));
        }

        /**
         * Selects column based on the column name and return it as a {@link Column}.
         * Note that the column name can also reference to a nested column like `a.b`.
         * @param colName
         * @since 1.3.0
         */

    }, {
        key: "col",
        value: function col(colName /*: String */) /*: Column */{
            return new Column(this.jvm_obj.col(colName));
        }

        /**
         * Selects a set of column based expressions.
         *
         * @param cols Array of column names or expressions.
                If one of the column names is '*', that column is expanded to include all columns
                in the current DataFrame.
         * @since 1.3.0
         */

    }, {
        key: "select",
        value: function select() /*: (Column* | String*) */ /*: DataFrame */{
            var _jvm_obj3;

            for (var _len2 = arguments.length, cols = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                cols[_key2] = arguments[_key2];
            }

            cols = cols.map(helpers.jobj_from_maybe_string);
            return new DataFrame((_jvm_obj3 = this.jvm_obj).select.apply(_jvm_obj3, _toConsumableArray(cols)));
        }

        /**
         * Selects a set of SQL expressions. This is a variant of `select` that accepts
         * SQL expressions.
         *
         * @param exprs Array of SQL expressions.
         * @since 1.3.0
         */

    }, {
        key: "selectExpr",
        value: function selectExpr() /*: String* */ /*: DataFrame */{
            var _jvm_obj4;

            return new DataFrame((_jvm_obj4 = this.jvm_obj).selectExpr.apply(_jvm_obj4, arguments));
        }

        /**
         * Filters rows using the given column expression or SQL expression.
         * @example <caption>The following are equivalent:</caption>
         *   peopleDf.filter(peopleDf.col("age").gt(15));
         *   peopleDf.filter("age > 15");
         * @param condition A {@link Column} of booleans or a string containing a SQL expression.
         * @since 1.3.0
         */

    }, {
        key: "filter",
        value: function filter(condition /*: Column|String */) /*: DataFrame */{
            condition = helpers.jobj_from_maybe_string(condition);
            return new DataFrame(this.jvm_obj.filter(condition));
        }

        /**
         * Filters rows using the given condition. This is an alias for `filter`.
         * @param condition
         * @since 1.3.0
         */

    }, {
        key: "where",
        value: function where(condition /*: Column|String */) /*: DataFrame */{
            condition = helpers.jobj_from_maybe_string(condition);
            return new DataFrame(this.jvm_obj.filter(condition));
        }

        /**
         * Groups the {@link DataFrame} using the specified columns, so we can run aggregations on them.
         * See {@link GroupedData} for all the available aggregation functions.
         *
         * @example <caption>Compute the average for all numeric columns grouped by department.</caption>
         *   df.groupBy("department").avg();
         *
         * @param cols Array of column names or expressions to group by.
         * @since 1.3.0
         */

    }, {
        key: "groupBy",
        value: function groupBy() /*: (Column* | String*) */ /*: GroupedData */{
            var _jvm_obj5;

            for (var _len3 = arguments.length, cols = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                cols[_key3] = arguments[_key3];
            }

            cols = cols.map(helpers.jobj_from_maybe_string);
            return new GroupedData((_jvm_obj5 = this.jvm_obj).groupBy.apply(_jvm_obj5, _toConsumableArray(cols)));
        }

        /**
         * Create a multi-dimensional rollup for the current {@link DataFrame} using the specified columns,
         * so we can run aggregations on them.
         * See {@link GroupedData} for all the available aggregation functions.
         *
         * @example
         * // Compute the average for all numeric columns rolluped by department and group
         *   df.rollup(df.col("department"), df.col("group")).avg();
         *
         * @param cols Array of column names or expressions.
         * @since 1.4.0
         */

    }, {
        key: "rollup",
        value: function rollup() /*: (Column* | String*) */ /*: GroupedData */{
            var _jvm_obj6;

            for (var _len4 = arguments.length, cols = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                cols[_key4] = arguments[_key4];
            }

            cols = cols.map(helpers.jobj_from_maybe_string);
            return new GroupedData((_jvm_obj6 = this.jvm_obj).rollup.apply(_jvm_obj6, _toConsumableArray(cols)));
        }

        /**
         * Create a multi-dimensional cube for the current {@link DataFrame} using the specified columns,
         * so we can run aggregation on them.
         * See {@link GroupedData} for all the available aggregation functions.
         *
         * @example
         *   // Compute the average for all numeric columns cubed by department and group.
         *   df.cube("department", "group").avg();
         *
         * @param cols Array of column names or expressions.
         * @since 1.4.0
         */

    }, {
        key: "cube",
        value: function cube() /*: (Column*|String*) */ /*: GroupedData */{
            var _jvm_obj7;

            for (var _len5 = arguments.length, cols = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                cols[_key5] = arguments[_key5];
            }

            cols = cols.map(helpers.jobj_from_maybe_string);
            return new GroupedData((_jvm_obj7 = this.jvm_obj).cube.apply(_jvm_obj7, _toConsumableArray(cols)));
        }

        /**
         * Aggregates on the entire {@link DataFrame} without groups.
         * @example
         *   // df.agg(...) is a shorthand for df.groupBy().agg(...)
         *   df.agg(F.max(df.col("age")), F.avg(df.col("salary")));
         *   df.groupBy().agg(F.max(df.col("age")), F.avg(df.col("salary")));
         *
         * @param cols Array of column names or expressions.
         * @since 1.3.0
         */

    }, {
        key: "agg",
        value: function agg() /*: Column* */ /*: DataFrame */{
            var _jvm_obj8;

            for (var _len6 = arguments.length, cols = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                cols[_key6] = arguments[_key6];
            }

            cols = cols.map(function (col) {
                return col.jvm_obj;
            });
            return new DataFrame((_jvm_obj8 = this.jvm_obj).agg.apply(_jvm_obj8, _toConsumableArray(cols)));
        }

        /**
         * Returns a new {@link DataFrame} by taking the first `n` rows. The difference between this function
         * and `head` is that `head` returns an array while `limit` returns a new {@link DataFrame}.
         * @param n Number of rows.
         * @since 1.3.0
         */

    }, {
        key: "limit",
        value: function limit(n /*: Int */) /*: DataFrame */{
            return new DataFrame(this.jvm_obj.limit(n));
        }

        /**
         * Returns a new {@link DataFrame} containing union of rows in this frame and another frame.
         * This is equivalent to `UNION ALL` in SQL.
         * @param other {@link DataFrame}
         * @since 1.3.0
         */

    }, {
        key: "unionAll",
        value: function unionAll(other /*: DataFrame */) /*: DataFrame */{
            return new DataFrame(this.jvm_obj.unionAll(other.jvm_obj));
        }

        /**
         * Returns a new {@link DataFrame} containing rows only in both this frame and another frame.
         * This is equivalent to `INTERSECT` in SQL.
         * @param other {@link DataFrame}
         * @since 1.3.0
         */

    }, {
        key: "intersect",
        value: function intersect(other /*: DataFrame */) /*: DataFrame */{
            return new DataFrame(this.jvm_obj.intersect(other.jvm_obj));
        }

        /**
         * Returns a new {@link DataFrame} containing rows in this frame but not in another frame.
         * This is equivalent to `EXCEPT` in SQL.
         * @param other {@link DataFrame}
         * @since 1.3.0
         */

    }, {
        key: "except",
        value: function except(other /*: DataFrame */) /*: DataFrame */{
            return new DataFrame(this.jvm_obj.except(other.jvm_obj));
        }

        /**
         * Returns a new {@link DataFrame} by sampling a fraction of rows, using a random seed.
         *
         * @param withReplacement Sample with replacement or not.
         * @param fraction Fraction of rows to generate.
         * @since 1.3.0
         */

    }, {
        key: "sample",
        value: function sample(withReplacement /*: Boolean */, fraction /*: Double */) /*: DataFrame */{
            return new DataFrame(this.jvm_obj.sample(withReplacement, fraction));
        }

        /**
         * Randomly splits this {@link DataFrame} with the provided weights.
         *
         * @param weights Weights for splits, will be normalized if they don't sum to 1.
         * @since 1.4.0
         */

    }, {
        key: "randomSplit",
        value: function randomSplit() /*: Double* */ /*: Array[DataFrame]*/{

            throw new Error("Not implemented");

            // for some reason, this crashes the jvm. yet constructing the array
            // in the shell and passing it directly works. haven't dug into the
            // node-java code yet.

            /*eslint-disable no-unreachable*/

            for (var _len7 = arguments.length, weights = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                weights[_key7] = arguments[_key7];
            }

            var weightsArray = java.newArray("double", weights);

            return this.jvm_obj.randomSplit(weightsArray);
            /*eslint-enable no-unreachable*/
        }

        /**
         * Returns a new {@link DataFrame} by adding a column or replacing the existing column that has
         * the same name.
         * @param colName Name of the new column.
         * @param col {@link Column} Expression for the new column.
         * @since 1.3.0
         */

    }, {
        key: "withColumn",
        value: function withColumn(colName /*: String */, col /*: Column */) /*: DataFrame */{
            col = helpers.jobj_from_maybe_string(col);
            return new DataFrame(this.jvm_obj.withColumn(colName, col));
        }

        /**
         * Returns a new {@link DataFrame} with a column dropped.
         * This is a no-op if schema doesn't contain column name.
         * @param col {@link Column}
         * @since 1.4.0
         */

    }, {
        key: "drop",
        value: function drop(col /*: String|Column */) /*: DataFrame */{
            col = helpers.jobj_from_maybe_string(col);
            return new DataFrame(this.jvm_obj.drop(col));
        }

        /**
         * Returns a new {@link DataFrame} that contains only the unique rows from this {@link DataFrame}.
         * This is an alias for `distinct`.
         * If column names are passed in, rows are only compared in those columns.
         *
         * @param colNames Array of column names.
         * @since 1.4.0
         */

    }, {
        key: "dropDuplicates",
        value: function dropDuplicates() /*: String* */ /*: DataFrame */{
            var _jvm_obj9;

            return new DataFrame((_jvm_obj9 = this.jvm_obj).drop.apply(_jvm_obj9, arguments));
        }

        /**
         * Returns a new {@link DataFrame} that contains only the unique rows from this {@link DataFrame}.
         * This is an alias for `dropDuplicates`.
         * @since 1.3.0
         */

    }, {
        key: "distinct",
        value: function distinct() /*: DataFrame */{
            return new DataFrame(this.jvm_obj.drop());
        }

        /**
         * Computes statistics for numeric columns, including count, mean, stddev, min, and max.
         * If no columns are given, this computes statistics for all numerical columns.
         *
         * This is meant for exploratory data analysis, as we make no guarantee about the
         * backward compatibility of the schema of the resulting {@link DataFrame}. If you want to
         * programmatically compute summary statistics, use the `agg` method instead.
         *
         * @example
         *   df.describe("age", "height").show();
         *
         *   // output:
         *   // summary age   height
         *   // count   10.0  10.0
         *   // mean    53.3  178.05
         *   // stddev  11.6  15.7
         *   // min     18.0  163.0
         *   // max     92.0  192.0
         *
         * @param colNames Array of column names.
         *
         * @since 1.3.1
         */

    }, {
        key: "describe",
        value: function describe() /*: String* */ /*: DataFrame */{
            var _jvm_obj10;

            return new DataFrame((_jvm_obj10 = this.jvm_obj).describe.apply(_jvm_obj10, arguments));
        }

        /**
         * Returns the first `n` rows.
         *
         * Running head requires moving data into the application's driver process, and doing so with
         * a very large `n` can crash the driver process with OutOfMemoryError.
         *
         * @param {Number} [n=1] Number of rows to return.
         * @param cb Node-style callback function (error-first).
         *
         * @since 1.3.0
         */

    }, {
        key: "head",
        value: function head(cb /*: cb: (err: any, res: Array[Object]) =>  any */) /*: Int */ /*: void */{
            var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            var jvm_cb = function jvm_cb(err, jvm_rows) {
                if (err) return cb(err);
                cb(err, jvm_rows.map(function (row) {
                    return new Row(row).values();
                }));
            };

            return this.jvm_obj.headAsync(n, jvm_cb);
        }

        /**
         * The synchronous version of {@link DataFrame#head}
         *
         * @param {Number} [n=1] Number of rows to return.
         *
         * @since 1.3.0
         */

    }, {
        key: "headSync",
        value: function headSync() /*: Int */ /*: Array[Object]*/{
            var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

            return this.jvm_obj.head(n).map(function (row) {
                return new Row(row).values();
            });
        }

        /**
         * Returns an array that contains all of {@link Row}s in this {@link DataFrame}.
         *
         * Running collect requires moving all the data into the application's driver process, and
         * doing so on a very large dataset can crash the driver process with OutOfMemoryError.
         *
         * @param cb Node-style callback function (error-first).
         * @since 1.3.0
         */

    }, {
        key: "collect",
        value: function collect(cb /*: cb: (err: any, res: Array[Object]) =>  any */) /*: void*/{
            var jvm_cb = function jvm_cb(err, jvm_rows) {
                if (err) return cb(err);
                cb(err, jvm_rows.map(function (row) {
                    return new Row(row).values();
                }));
            };
            this.jvm_obj.collectAsync(jvm_cb);
        }

        /**
         * The synchronous version of {@link DataFrame#collect}
         *
         * @since 1.3.0
         */

    }, {
        key: "collectSync",
        value: function collectSync() /*: Array[Object]*/{
            return this.jvm_obj.collect().map(function (row) {
                return new Row(row).values();
            });
        }

        /**
         * Returns the number of rows in the {@link DataFrame}.
         *
         * @param cb Node-style callback function (error-first).
         * @since 1.3.0
         */

    }, {
        key: "count",
        value: function count(cb /*: cb: (err: any, res: Number) =>  any */) /*: void*/{
            var jvm_cb = function jvm_cb(err, res) {
                if (err) return cb(err);
                cb(err, res.valueOf());
            };

            this.jvm_obj.countAsync(jvm_cb);
        }

        /**
         * The synchronous version of {@link DataFrame#count}
         * @since 1.3.0
         */

    }, {
        key: "countSync",
        value: function countSync() /*: Number */{
            return this.jvm_obj.count().valueOf();
        }

        /**
         * Returns a partitioned {@link DataFrame}.
         *
         * If partition expressions are provided, partition by the given
         * partitioning expressions into `numPartitions`. The resulting DataFrame
         * is hash partitioned. (This is the same operation as "DISTRIBUTE BY" in
         * SQL (Hive QL).)
         *
         * @param {Number} [numPartitions] Number of partitions.
         * @param partitionExprs Partitioning expressions.
         * @since 1.3.0
         */

    }, {
        key: "repartition",
        value: function repartition(numPartitions /*: Int */) /*: Column* */ /*: DataFrame */{
            for (var _len8 = arguments.length, partitionExprs = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
                partitionExprs[_key8 - 1] = arguments[_key8];
            }

            if (partitionExprs.length === 0) {
                return new DataFrame(this.jvm_obj.repartition(numPartitions));
            } else {
                return new DataFrame(this.jvm_obj.repartition(numPartitions, partitionExprs));
            }
        }

        /**
         * Registers this {@link DataFrame} as a temporary table using the given name.  The lifetime of this
         * temporary table is tied to the {@link SQLContext} that was used to create this DataFrame.
         *
         * @param tableName Table name.
         * @since 1.3.0
         */

    }, {
        key: "registerTempTable",
        value: function registerTempTable(tableName /*: String */) /*: Unit */{
            this.jvm_obj.registerTempTable(tableName);
        }

        /**
         * Interface for saving the content of the {@link DataFrame} out into external storage.
         * @since 1.4.0
         */

    }, {
        key: "write",
        value: function write() /*: DataFrameWriter*/{
            return new DataFrameWriter(this);
        }
    }]);

    return DataFrame;
}();

module.exports = DataFrame;