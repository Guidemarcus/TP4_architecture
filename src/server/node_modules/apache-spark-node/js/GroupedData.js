"use strict";

/**
 * A set of methods for aggregations on a {@link DataFrame}, created by {@link DataFrame#groupBy}.
 *
 * The main method is {@link GroupedData#agg}. This class also contains some
 * first order statistics (such as mean or sum) for convenience.
 *
 * @since 1.3.0
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GroupedData = function () {

  /**
   * **Note:** Do not use directly (see above).
   */
  function GroupedData(jvm_obj /*: SQLContext*/) {
    _classCallCheck(this, GroupedData);

    this.jvm_obj = jvm_obj;
  }

  /**
   * Compute aggregates by specifying a series of aggregate columns. Note that this function by
   * default retains the grouping columns in its output. To not retain grouping columns, set
   * `spark.sql.retainGroupColumns` to false.
   *
   * The available aggregate functions are defined in {@link Functions}.
   *
   * @example
   * // Select the age of the oldest employee and the aggregate expense for each department
   * df.groupBy("department").agg(F.max("age"), F.sum("expense"));
   *
   * @param expr Array of columns to group by.
   *
   * @since 1.3.0
   */


  _createClass(GroupedData, [{
    key: "agg",
    value: function agg() /*: Column* */ /*: DataFrame*/{
      var _jvm_obj;

      return (_jvm_obj = this.jvm_obj).agg.apply(_jvm_obj, arguments);
    }

    /**
     * Count the number of rows for each group.
     * The resulting {@link DataFrame} will also contain the grouping columns.
     *
     * @since 1.3.0
     */

  }, {
    key: "count",
    value: function count() /*: DataFrame */{
      // run-time require is ugly workaround for issues with import cycle.
      var DataFrame = require("./DataFrame");
      return new DataFrame(this.jvm_obj.count());
    }

    /**
     * Compute the average value for each numeric columns for each group.
     * The resulting {@link DataFrame} will also contain the grouping columns.
     * When specified columns are given, only compute the average values for them.
     *
     * @param colNames Array of columns to compute mean over.
     * @since 1.3.0
     */

  }, {
    key: "avg",
    value: function avg() /*: String* */ /*: DataFrame*/{
      var _jvm_obj2;

      return (_jvm_obj2 = this.jvm_obj).mean.apply(_jvm_obj2, arguments);
    }

    /**
     * Compute the max value for each numeric columns for each group.
     * The resulting {@link DataFrame} will also contain the grouping columns.
     * When specified columns are given, only compute the max values for them.
     *
     * @param colNames Array of columns to compute max over.
     * @since 1.3.0
     */

  }, {
    key: "max",
    value: function max() /*: String* */ /*: DataFrame*/{
      var _jvm_obj3;

      return (_jvm_obj3 = this.jvm_obj).max.apply(_jvm_obj3, arguments);
    }

    /**
     * Alias for {@link GroupedData#avg}.
     *
     * @param colNames Array of columns to compute mean over.
     *
     * @since 1.3.0
     */

  }, {
    key: "mean",
    value: function mean() /*: String* */ /*: DataFrame*/{
      var _jvm_obj4;

      return (_jvm_obj4 = this.jvm_obj).mean.apply(_jvm_obj4, arguments);
    }

    /**
     * Compute the min value for each numeric column for each group.
     * The resulting {@link DataFrame} will also contain the grouping columns.
     * When specified columns are given, only compute the min values for them.
     *
     * @param colNames Array of columns to compute min over.
     *
     * @since 1.3.0
     */

  }, {
    key: "min",
    value: function min() /*: String* */ /*: DataFrame*/{
      var _jvm_obj5;

      return (_jvm_obj5 = this.jvm_obj).min.apply(_jvm_obj5, arguments);
    }

    /**
     * Compute the sum for each numeric columns for each group.
     * The resulting {@link DataFrame} will also contain the grouping columns.
     * When specified columns are given, only compute the sum for them.
     *
     * @param colNames Array of columns to compute sum over.
     *
     * @since 1.3.0
     */

  }, {
    key: "sum",
    value: function sum() /*: String* */ /*: DataFrame*/{
      var _jvm_obj6;

      return (_jvm_obj6 = this.jvm_obj).sum.apply(_jvm_obj6, arguments);
    }
  }]);

  return GroupedData;
}();

module.exports = GroupedData;